
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[top=4cm,bottom=4cm,right=4cm,left=4cm]{geometry}
#+latex_class: article
#+latex_class_options: [a4paper]


#+title: *RAPPORT PROJET 2048*
#+author: Emery, Gouraud, Kirov, Pouteau
#+startup: indent
\newpage
* Introduction

Dans le cadre de l'UE Environnement de Développement et Projet de
Programmation 1, nous avons été amené à créer un jeu 2048.\\
*Ce jeu consiste* à obtenir une tuile de valeur 2048 en fusionnant des
tuiles de même valeur de manière à en obtenir une deux fois plus
grande. Le jeu commence avec deux tuiles de valeur aléatoire (2 ou 4). Il se joue
sur une grille de 4x4, avec quatre déplacements possibles (Haut, Bas, Droite, Gauche). 
A chaque déplacement un tuile de valeur 2 ou 4 apparaît aléatoirement sur la grille.\\
Ce jeu est une application mobile sortie en mars 2014, programmé par
Gabriele Circulli, un web-designer italien. Il s'est inspiré du jeu
1024 dont le principe est identique sauf le but qui est
d'atteindre pour le coup 1024. Ce jeu 1024 est lui-même basé sur Threes un jeu du
même style.\\

\noindent
Lien pour tester les différents jeux: 

 [[http://gabrielecirulli.github.io/2048/][- lien 2048]]

 [[http://1024game.org][- lien 1024]]

 [[http://threesjs.com][- lien Threes]]
\newpage

* Description Projet

Le projet a été séparé en deux parties différentes.
- Réalisation de l'implémentation du 2048 et création d'une interface
  graphique sur le terminal.
- Réalisation d'une interface graphique indépendante et conception de
  deux IA capable de résoudre le 2048.


** Implémentation du 2048
*** Fonction de Base
Implémentation des fonctions décriteq dans l'interface fournit
/grid.h/.

#+BEGIN_SRC c
/* Créer une nouvelle grille */
grid new_grid ();

/* Supprime la grille passée en paramètre*/
void delete_grid (grid g); 

/* Copie une grille src dans une grille dst */
void copy_grid (grid src, grid dst);

/* Renvoie le score actuel du jeu */
unsigned long int grid_score (grid g);

/* Renvoie la valeur d'une tuile */ 
tile get_tile (grid g, int x, int y); 

/* Met la valeur t dans une tuile  */
void set_tile (grid g, int x, int y, tile t);

/* Verifie que la direction 'd' est valide */ 
bool can_move (grid g, dir d); 

/* Renvoie game_over si il n'y a plus de déplacement possible */
bool game_over (grid g);

/* Effectue un mouvement selon la direction 'd' */
void do_move (grid g, dir d);

/* Ajoute une tuile aléatoirement de valeur 2 ou 4 sur la grille. */
void add_tile (grid g); 

/* Effectue le mouvement et ajoute une tuile */
void play (grid g, dir d);
#+END_SRC

\vspace{0.5cm}
Ces fonctions permettent le bon fonctionnement du jeu.  
Nous avons essayé de simplifier toutes ces fonctions de bases. Pour
cela, et afin d'éviter des duplications de code notamment dans
=can_move= et =do_move=, nous avons fait appel à des fonctions static.
 
\newpage
*** Fonction static
\noindent
_Déclaration des fonctions static de grid.c_:
#+BEGIN_SRC c 
/* Permet d'incrémenter deux variables ayant des incrémentations différentes. */
static void 
incrementation(int *i1, int *i2, int incrementationI1, int incrementationI2)

/*
 * Déplace l'ensemble de la grille dans la direction voulue 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static void move(grid g, int i, int j, int a, int b);

/*
 * Teste sur l'ensemble de la grille si le deplacement dans la direction 
 * voulue est faisable (en fonction des paramètres) 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static bool possible(grid g, int i, int j, int a, int b);

/* Fusionne deux cases et met la deuxième case à 0 */
static void fusion(grid g, int i, int j, int a, int b);

/* Ajoute add_score au score de la grid */
static void set_grid_score(grid g, unsigned long int add_score);
#+END_SRC

\bigskip
_Description de l'utilisation des fonctions static_: 
- move :
  Elle sert à simplifier la fonction =do_move=, car elle effectue tous 
  les déplacements en fonction des paramètres fournis. Par conséquent,
  =do_move= est reduite a appelé simplement =move= avec les bons paramètre.
- fusion :
  Elle est utilisée pour faire les fusions dans la fonction =move=.
- incrementation :
  Elle permet d'évité la repétition de code due a l'incrementation des
  variable dans =move= et =possible=.
- possible : 
  Elle permet de simplifier la fonction =can_move=, car lorsqu'on lui passe
  certains paramètres, elle vérifie la possibilité de faire un
  mouvement. Ce qui reduit la fonction =can_move= à appeler la
  fonction =possible= avec les bons paramètres.
\newpage
*** Interface Graphique sur terminal
Nous avons choisi d'utilisé la bibliothèque Ncurses pour pouvoir
générer notre grille dans le terminal.\\
Le jeu se joue avec les flèches directionnelles. Nous avons intégré
des couleurs afin d'égayer l'affichage de notre jeu.\\
Nous proposons également des options supplémentaires:
- q: permet de quitter le jeu
- r: permet de recommencer le jeu
De plus, si vous perdez, on vous offre la possibilité de soit rejouer,
soit quitter le jeu.\\
Nous avons également intégré par esprit de challenge un Highscore. \\
L'affichage graphique s'adapte à la taille de la grille. Mais ne
modifie pas la taille du terminal d'où il est lancé.


*** Réalisation de test

Les tests sont déclenchés par la commande *make check*.
\bigskip\\
Nous avons utilisé gcov, ce qui nous a permis de savoir que notre
programme de test vérifie 94.96% de notre fichier grid.c.
Les 5% manquant sont dus au fait que l'on ne teste pas la fonction
=play= car elle utilise simplement deux autres fonctions testées précedemment.
 
#+BEGIN_EXAMPLE
File 'grid.c'
Ligne exécutées: 94.96% de 139
Creating 'grid.c.gcov'
#+END_EXAMPLE
\noindent
Nous avons testé indépendamment chaque déplacement, pour savoir
précisement quel déplacement pourrait provoquer une erreur. 


** Interface Graphique et Intelligence Artificielle

*** Interface Graphique SDL

A partir de la bibliothèque SDL et de ses bibliothèques tierces (SDL_image, 
SDL_ttf et SDL_getenv), nous avons créer l'interface graphique du 2048 sur 
une fenêtre indépendante. Cette fenêtre s'ouvre centré à l'écran, et s'adapte
à la taille de la grille (=GRID_SIDE=) définit dans le grid.h.
Le texte apparait parfaitement centré et est inhérent à =GRID_SIDE=. La police
du texte est aussi en adéquation avec la taille de la grille.//
L'interface graphique propose aussi de recommencer la partie (touche "Entrée"),
mais aussi d'abandonner (touche "Echap" ou la croix en haut à droite) et ferme 
le programme.//
Lorsque la partie se termine (c'est-à-dire lorsqu'aucun déplacement n'est possible),
le joueur (s'il a obtenu un nouvel Highscore), a la possibilité de mémoriser son 
pseudo. S'il n'entre pas son pseudo (en relançant la partie ou en quittant le programme),
le pseudo qui sera mis par défaut sera "Anyone".//
Le code est commenté de façon à être compréhensible, et les noms des variables
est en anglais.//
Aucune fuite de mémoire n'est à déplorer, mise à part celle de base liée à la
SDL et référencée.//

\newpage
* Architecture du Projet

