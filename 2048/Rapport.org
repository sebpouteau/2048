#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[top=4cm,bottom=4cm,right=4cm,left=4cm]{geometry}
#+latex_class: article
#+latex_class_options: [a4paper]


#+title: *RAPPORT PROJET 2048*
#+author: Emery, Gouraud, Kirov, Pouteau
#+startup: indent
\newpage
* Introduction

Dans le cadre de l'UE Environnement de Développement et Projet de
Programmation 1, nous avons été amené à créer un jeu 2048.\\
*Ce jeu consiste* à obtenir une tuile de valeur 2048 en fusionnant des
tuiles de même valeur de manière à en obtenir une deux fois plus
grande. Le jeu commence avec deux tuiles de valeur aléatoire (2 ou 4). Il se joue
sur une grille de 4x4, avec quatre déplacements possibles (Haut, Bas, Droite, Gauche). 
A chaque déplacement un tuile de valeur 2 ou 4 apparaÃ®t aléatoirement sur la grille.\\
Ce jeu est une application mobile sortie en mars 2014, programmé par
Gabriele Circulli, un web-designer italien. Il s'est inspiré du jeu
1024 dont le principe est identique sauf le but qui est
d'atteindre pour le coup 1024. Ce jeu 1024 est lui-même basé sur Threes un jeu du
même style.\\

\noindent
Lien pour tester les différents jeux: 

 [[http://gabrielecirulli.github.io/2048/][- lien 2048]]

 [[http://1024game.org][- lien 1024]]

 [[http://threesjs.com][- lien Threes]]
\newpage

* Description Projet
Le projet a été séparé en deux parties différentes.
- Réalisation de l'implémentation du 2048 et création d'une interface
  graphique sur le terminal.
- Réalisation d'une interface graphique indépendante et conception de
  deux IA capable de résoudre le 2048.


** Implémentation du 2048
*** Fonction de Base
Implémentation des fonctions décriteq dans l'interface fournit
/grid.h/.

#+BEGIN_SRC c
/* Créer une nouvelle grille */
grid new_grid ();

/* Supprime la grille passée en paramètre*/
void delete_grid (grid g); 

/* Copie une grille src dans une grille dst */
void copy_grid (grid src, grid dst);

/* Renvoie le score actuel du jeu */
unsigned long int grid_score (grid g);

/* Renvoie la valeur d'une tuile */ 
tile get_tile (grid g, int x, int y); 

/* Met la valeur t dans une tuile  */
void set_tile (grid g, int x, int y, tile t);

/* Verifie que la direction 'd' est valide */ 
bool can_move (grid g, dir d); 

/* Renvoie game_over si il n'y a plus de déplacement possible */
bool game_over (grid g);

/* Effectue un mouvement selon la direction 'd' */
void do_move (grid g, dir d);

/* Ajoute une tuile aléatoirement de valeur 2 ou 4 sur la grille. */
void add_tile (grid g); 

/* Effectue le mouvement et ajoute une tuile */
void play (grid g, dir d);
#+END_SRC

\vspace{0.5cm}
Ces fonctions permettent le bon fonctionnement du jeu.  
Nous avons essayé de simplifier toutes ces fonctions de bases. Pour
cela, et afin d'éviter des duplications de code notamment dans
=can_move= et =do_move=, nous avons fait appel à des fonctions static.
 
\newpage
*** Fonction static
\noindent
_Déclaration des fonctions static de grid.c_:
#+BEGIN_SRC c 
/* Permet d'incrémenter deux variables ayant des incrémentations différentes. */
static void 
incrementation(int *i1, int *i2, int incrementationI1, int incrementationI2)

/*
 * Déplace l'ensemble de la grille dans la direction voulue 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static void move(grid g, int i, int j, int a, int b);

/*
 * Teste sur l'ensemble de la grille si le deplacement dans la direction 
 * voulue est faisable (en fonction des paramètres) 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static bool possible(grid g, int i, int j, int a, int b);

/* Fusionne deux cases et met la deuxième case à 0 */
static void fusion(grid g, int i, int j, int a, int b);

/* Ajoute add_score au score de la grid */
static void set_grid_score(grid g, unsigned long int add_score);
#+END_SRC

\bigskip
_Description de l'utilisation des fonctions static_: 
- move :
  Elle sert à simplifier la fonction =do_move=, car elle effectue tous 
  les déplacements en fonction des paramètres fournis. Par conséquent,
  =do_move= est reduite a appelé simplement =move= avec les bons paramètre.
- fusion :
  Elle est utilisée pour faire les fusions dans la fonction =move=.
- incrementation :
  Elle permet d'évité la repétition de code due a l'incrementation des
  variable dans =move= et =possible=.
- possible : 
  Elle permet de simplifier la fonction =can_move=, car lorsqu'on lui passe
  certains paramètres, elle vérifie la possibilité de faire un
  mouvement. Ce qui reduit la fonction =can_move= à appeler la
  fonction =possible= avec les bons paramètres.
\newpage
*** Interface Graphique sur terminal

Nous avons choisi d'utilisé la bibliothèque Ncurses pour pouvoir
générer notre grille dans le terminal.\\
Le jeu se joue avec les flèches directionnelles. Nous avons intégré
des couleurs afin d'égayer l'affichage de notre jeu.\\
Nous proposons également des options supplémentaires:
- q: permet de quitter le jeu
- r: permet de recommencer le jeu
De plus, si vous perdez, on vous offre la possibilité de soit rejouer,
soit quitter le jeu.\\
Nous avons également intégré par esprit de challenge un Highscore. \\
L'affichage graphique s'adapte à la taille de la grille. Mais ne
modifie pas la taille du terminal d'où il est lancé.
*** Réalisation de test

Les tests sont déclenchés par la commande *make check*.
\bigskip\\
Nous avons utilisé gcov, ce qui nous a permis de savoir que notre
programme de test vérifie 94.96% de notre fichier grid.c.
Les 5% manquant sont dus au fait que l'on ne teste pas la fonction
=play= car elle utilise simplement deux autres fonctions testées précedemment.
 
#+BEGIN_EXAMPLE
File 'grid.c'
Ligne exécutées: 94.96% de 139
Creating 'grid.c.gcov'
#+END_EXAMPLE
\noindent
Nous avons testé indépendamment chaque déplacement, pour savoir
précisement quel déplacement pourrait provoquer une erreur. 


Les tests ont été réalisé de manière a être extansible c'est à dire
que quelque soit la valeur de =GRID_SIDE= les tests permettent de
tester les différentes fonctions.



** Interface Graphique 
*** Interface Graphique SDL

A partir de la bibliothèque SDL et de ses bibliothèques tierces (SDL_image, 
SDL_ttf et SDL_getenv), nous avons créer l'interface graphique du 2048 sur 
une fenêtre indépendante. Cette fenêtre s'ouvre centré à l'écran, et s'adapte
à la taille de la grille (=GRID_SIDE=) définit dans le grid.h.
Le texte apparait parfaitement centré et est inhérent à =GRID_SIDE=. La police
du texte est aussi en adéquation avec la taille de la grille.//
L'interface graphique propose aussi de recommencer la partie (touche "Entrée"),
mais aussi d'abandonner (touche "Echap" ou la croix en haut à droite) et ferme 
le programme.//
Lorsque la partie se termine (c'est-à-dire lorsqu'aucun déplacement n'est possible),
le joueur (s'il a obtenu un nouvel Highscore), a la possibilité de mémoriser son 
pseudo. S'il n'entre pas son pseudo (en relanÃ§ant la partie ou en quittant le programme),
le pseudo qui sera mis par défaut sera "Anyone".//
Le code est commenté de faÃ§on à être compréhensible, et les noms des variables
est en anglais.//
Aucune fuite de mémoire n'est à déplorer, mise à part celle de base liée à la
SDL et référencée.//

Nous avons intégré des options supplémentaire. Le jeu se lance sur un
menu qui permet de choisir le degrader des tuiles du jeu. Deplus nous
durant la partie on peut égalament changer la couleur grâce aux
touches "f1" "f2" et "f3".//
Nous avons intégré une petite animation dans le menu de départ.

\newpage
*** Intelligence Artificielle
Nous avons implémenté deux intélligence artificielle une qui doit
réalisé le meilleur score en 10secondes et une autre en moins de 2
minutes.

Pour observer nos intélligence artificielle a l'oeuvre nous avons
conçu deux programmes de visualisation. La première permettant de
répeter n fois l'intélligence artificielle et une autres permettant
de l'observer grâce à un affichage ncurses, un mouvement est fait a
chaque fois que l'on presse la touche "UP".

_Le principe de notre fonction d'exploration_:
Elle créé un tableau de 4 cases permettant de stocker les scores issus
des 4 directions. Si la profondeur est de 0 alors elle renvoye la note
de la grille encour. Tout d'abord la fonction effectue un mouvement puis
elle génère l'appartion de 2 puis se rappele avec n-1 en pronfondeur
puis elle fait de même avec l'appartion de 4. Elle stock alors la
moyenne des scores obtenu dans la cases du tableau correspondant a la
direction de départ. Et en fin elle retourne le meilleur score entre
les directions possibles. En parallèle elle modifie une variable
direction passer par reference. Le mouvement à effectuer est alors
cette variable direction.


Nos deux Intélligences artificielle explore a une profondeur de 2.

**** Intélligence Artificielle Rapide
Dans l'intélligence artificielle rapide, nous avons désidé de faire
une exploration de 3 lorsque qu'il ne reste 0 ou 1 case vide dans la
grille.
**** Intélligence Artificielle Lente
Dans l'intélligence artificielle rapide, nous avons désidé de faire
une exploration de:
- 3 pour lorsque qu'il reste moins de 6 cases vide
- 4 pour lorsque qu'il reste moins de 3 cases vide
- 5 pour lorsque qu'il reste moins de 2 cases vide
**** Fonction de notation 

* Architecture du Projet
\newpage
#+BEGIN_EXAMPLE

  Projet-Jeu 
       |                                                                                      
       + - README.txt                                             
       + - Makefile                                           
       + - include                                      
       |    |                                      
       |    + - grid.h                                      
       |    + - strategy.h                                      
       |    + - gridSDL.h                                      
       |
       + - src
            |                                           
            + - grid                                           
            |     |                                      
            |     + - Makefile                                      
            |     + - grid.c                                      
            |
            + - test-fonction                                      
            |     |                                      
            |     + - Makefile                                      
            |     + - fonction-test.c                                      
            |     + - main-fonction-test.c                                      
            |                                          
            + - ncurses
            |     |
            |     + - Makefile                                      
            |     + - main-ncurses.c                                      
            |     + - highscore_ncurses.txt                                      
            |                                           
            + - sdl
            |     |                                      
            |     + - Makefile                                      
            |     + - gridSDL.c                                      
            |     + - main-sdl.c
            |     + - arial.ttf                                      
            |     + - leadcoat.ttf                                      
            |     + - animation_penguin                                     
            |     |     + ...                               
            |     |                                      
            |     + - menu_button                                     
            |     |     + ...                               
            |     |                                      
            |     + - tiles
            |           |                                 
            |           + - blue
            |           |     + ...                               
            |           |                                 
            |           + - green
            |           |     + ...                               
            |           | 
            |           + - red
            |                 + ...                               
            |                                           
            + - startegy
                  |                                      
                  + - Makefile                                      
                  + - A2_emery_gouraud_kirov_pouteau_fast.c
                  + - A2_emery_gouraud_kirov_pouteau_fast.c
                  + - main-graphique-fast.c
                  + - main-repetition-fast.c
                  + - main-graphique-low.c
                  + - main-repetition-low.c
                  

#+END_EXAMPLE
