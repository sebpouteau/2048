#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[top=4cm,bottom=4cm,right=4cm,left=4cm]{geometry}
#+latex_class: article
#+latex_class_options: [a4paper]


#+title: *RAPPORT PROJET 2048*
#+author: Emery, Gouraud, Kirov, Pouteau
#+startup: indent
\newpage
* Introduction

Dans le cadre de l'UE Environnement de Développement et Projet de
Programmation 1, nous avons été amené à créer un jeu 2048.\\
*Ce jeu consiste* à obtenir une tuile de valeur 2048 en fusionnant des
tuiles de même valeur de manière à en obtenir une deux fois plus
grande. Le jeu commence avec deux tuiles de valeur aléatoire (2 ou 4). Il se joue
sur une grille de 4x4, avec quatre déplacements possibles (Haut, Bas, Droite, Gauche). 
A chaque déplacement une tuile de valeur 2 ou 4 apparait aléatoirement sur la grille.\\
Ce jeu est une application mobile sortie en mars 2014, programmé par
Gabriele Circulli, un web-designer italien. Il s'est inspiré du jeu
1024 dont le principe est identique sauf le but qui est
d'atteindre pour le coup 1024. Ce jeu 1024 est lui-même basé sur Threes un jeu du
même style.\\

\noindent
Lien pour tester les différents jeux: 

 [[http://gabrielecirulli.github.io/2048/][- lien 2048]]

 [[http://1024game.org][- lien 1024]]

 [[http://threesjs.com][- lien Threes]]
\newpage

* Description Projet
Le projet a été séparé en deux parties différentes.
- Réalisation de l'implémentation du 2048 et création d'une interface
  graphique sur le terminal.
- Réalisation d'une interface graphique indépendante et conception de
  deux IA capables de résoudre le 2048.


** Implémentation du 2048
*** Fonction de Base
Implémentation des fonctions décrites dans l'interface fournis
/grid.h/.

#+BEGIN_SRC c
/* Créer une nouvelle grille */
grid new_grid ();

/* Supprime la grille passée en paramètre*/
void delete_grid (grid g); 

/* Copie une grille src dans une grille dst */
void copy_grid (grid src, grid dst);

/* Renvoie le score actuel du jeu */
unsigned long int grid_score (grid g);

/* Renvoie la valeur d'une tuile */ 
tile get_tile (grid g, int x, int y); 

/* Met la valeur t dans une tuile  */
void set_tile (grid g, int x, int y, tile t);

/* Verifie que la direction 'd' est valide */ 
bool can_move (grid g, dir d); 

/* Renvoie game_over si il n'y a plus de déplacement possible */
bool game_over (grid g);

/* Effectue un mouvement selon la direction 'd' */
void do_move (grid g, dir d);

/* Ajoute une tuile aléatoirement de valeur 2 ou 4 sur la grille. */
void add_tile (grid g); 

/* Effectue le mouvement et ajoute une tuile */
void play (grid g, dir d);
#+END_SRC

\vspace{0.5cm}
Ces fonctions permettent le bon fonctionnement du jeu.  
Nous avons essayé de simplifier toutes ces fonctions de bases. Pour
cela, et afin d'éviter des duplications de code notamment dans
=can_move= et =do_move=, nous avons fait appel à des fonctions static.
 
\newpage
*** Fonction static
\noindent
_Déclaration des fonctions static de grid.c_:
#+BEGIN_SRC c 
/* Permet d'incrémenter deux variables ayant des incrémentations différentes. */
static void 
incrementation(int *i1, int *i2, int incrementationI1, int incrementationI2)

/*
 * Déplace l'ensemble de la grille dans la direction voulue 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static void move(grid g, int i, int j, int a, int b);

/*
 * Teste sur l'ensemble de la grille si le deplacement dans la direction 
 * voulue est faisable (en fonction des paramètres) 
 * Les directions prérequis :   UP    -> (grid, 0, 0, 0, 1)
 *                              DOWN  -> (grid, 0, GRID_SIDE - 1, 0, -1)
 *                              LEFT  -> (grid, 0, 0, 1, 0)
 *                              RIGHT -> (grid, GRID_SIDE - 1, 0, -1, 0)
 */
static bool possible(grid g, int i, int j, int a, int b);

/* Fusionne deux cases et met la deuxième case à 0 */
static void fusion(grid g, int i, int j, int a, int b);

/* Ajoute add_score au score de la grid */
static void set_grid_score(grid g, unsigned long int add_score);
#+END_SRC

\bigskip
_Description de l'utilisation des fonctions static_: 
- move :
  Elle sert à simplifier la fonction =do_move=, car elle effectue tous 
  les déplacements en fonction des paramètres fournis. Par conséquent,
  =do_move= est reduite a appelé simplement =move= avec les bons paramètre.
- fusion :
  Elle est utilisée pour faire les fusions dans la fonction =move=.
- incrementation :
  Elle permet d'éviter la repétition de code due à l'incrémentation des
  variables dans =move= et =possible=.
- possible : 
  Elle permet de simplifier la fonction =can_move=, car lorsqu'on lui passe
  certains paramètres, elle vérifie la possibilité de faire un
  mouvement. Ce qui réduit la fonction =can_move= à appeler la
  fonction =possible= avec les bons paramètres.
\newpage
*** Réalisation de test

Les tests sont déclenchés par la commande *make check*.
\bigskip\\
Nous avons utilisé gcov, ce qui nous a permis de savoir que notre
programme de test vérifie 94.96% de notre fichier grid.c.
Les 5% manquant sont dus au fait que l'on ne teste pas la fonction
=play= car elle utilise simplement deux autres fonctions testées précédemment.

#+BEGIN_EXAMPLE
File 'grid.c'
Ligne exécutées: 94.96% de 139
Creating 'grid.c.gcov'
#+END_EXAMPLE
\noindent
Nous avons testé indépendamment chaque déplacement, pour savoir
précisément quel déplacement pourrait provoquer une erreur. 


Les tests ont été réalisé de manière a être extensible c'est-à-dire
que quelque soit la valeur de =GRID_SIDE= les tests permettent de
tester les différentes fonctions.



** Interface Graphique 
*** Interface Graphique sur terminal

Nous avons choisi d'utiliser la bibliothèque Ncurses pour pouvoir
générer notre grille dans le terminal.\\
Le jeu se joue avec les flèches directionnelles. Nous avons intégré
des couleurs afin d'égayer l'affichage de notre jeu.\\
Nous proposons également des options supplémentaires:
- q: permet de quitter le jeu
- r: permet de recommencer le jeu
De plus, si vous perdez, on vous offre la possibilité de soit rejouer,
soit quitter le jeu.\\
Nous avons également intégré, par esprit de challenge, un Highscore. \\
L'affichage graphique s'adapte à la taille de la grille. Mais ne
modifie pas la taille du terminal d'où il est lancé.

*** Interface Graphique SDL

A partir de la bibliothèque SDL et de ses bibliothèques tierces (SDL_image, 
SDL_ttf et SDL_getenv), nous avons créer l'interface graphique du 2048 sur 
une fenêtre indépendante. Cette fenêtre s'ouvre centré à l'écran, et s'adapte
à la taille de la grille (=GRID_SIDE=) définit dans le grid.h.
Le texte apparait parfaitement centré et est inhérent à =GRID_SIDE=. La police
du texte est aussi en adéquation avec la taille de la grille.\\
L'interface graphique propose aussi de recommencer la partie (touche "Entrée"),
mais aussi d'abandonner (touche "Echap" ou la croix en haut à droite) et ferme 
le programme.\\
Lorsque la partie se termine (c'est-à-dire lorsqu'aucun déplacement n'est possible),
le joueur (s'il a obtenu un nouvel Highscore) à la possibilité de mémoriser son 
pseudo. S'il n'entre pas son pseudo (par exemple : en relançant la partie ou en quittant le programme),
le pseudo qui sera mis par défaut sera "Anyone".\\
Le code est commenté de façon à être compréhensible, et le nom des variables
est en anglais.\\
Il n'y a aucune fuite de mémoire, mise à part celle de base liée à la
SDL et référencée.\\

Nous avons intégré des options supplémentaire. Le jeu se lance sur un
menu qui permet de choisir le dégrader des tuiles du jeu. De plus, nous
pouvons égalament changer la couleur grâce aux touches "F1" "F2" et "F3" durant la partie.
Cela n'est pas clairement précisé, car il s'agit en faite d'un easter egg.//
Nous avons pour finir, intégré une petite animation dans le menu du jeu.

\newpage
** Intelligence Artificielle

Nous avons implémenté deux intelligences artificielles, une qui doit
réalisé le meilleur score en moins de 10 secondes et une autre en moins de 2
minutes.

Pour observer nos intelligence artificielle à l'oeuvre nous avons
conçu deux programmes de visualisation. La première permettant de
répeter n fois l'intelligence artificielle et une autre permettant
de l'observer grâce à un affichage Ncurses, un mouvement est fait à
chaque fois que l'on presse la touche "UP".

_Le principe de notre fonction d'exploration_:
Elle créé un tableau de 4 cases permettant de stocker les scores issus
des 4 directions. Si la profondeur est de 0 alors elle renvoie la note
de la grille en cours. Tout d'abord, la fonction effectue un mouvement
dans une direction à la profondeur n, puis elle génère l'apparition de 
la tuile 2 sur une case vide de la grille et la fonction se rappelle 
avec une profondeur de n-1. Elle fait de même avec l'apparition d'un 4 
sur la même case vide. Elle effectue cette série d'opérations sur toutes 
les cases vides de la grille courante. Une fois qu'elle a parcouru toutes 
les cases vides, elle calcule la moyenne des notes obtenues. Elle la stock 
alors dans la case du tableau correspondant à la direction effectué. 
Elle choisie ensuite la meilleure note parmi les 4 directions et la renvoie. 
En parallèle, elle modifie une variable de direction passée par référence. 
Le mouvement à effectuer est alors cette variable directionnelle.


*** Intelligence Artificielle Rapide
Dans l'intelligence artificielle rapide, nous avons décidé de faire une 
exploration de 2 et d'étendre à 3 lorsque qu'il ne reste que 0 ou 1 case 
vide dans la grille.

\noindent
#+BEGIN_EXAMPLE
Sur 1000 lancés :

Nombre de fois 16 : 0
Nombre de fois 32 : 0
Nombre de fois 64 : 0
Nombre de fois 128 : 0
Nombre de fois 256 : 0
Nombre de fois 512 : 9
Nombre de fois 1024 : 81
Nombre de fois 2048 : 585
Nombre de fois 4096 : 322
Nombre de fois 8192 : 3

#+END_EXAMPLE
*** Intelligence Artificielle Lente
Dans l'intelligence artificielle rente, nous avons décidé de faire
une exploration de profondeur:
- 2 par defaut
- 3 pour lorsque qu'il reste moins de 6 cases vide
- 4 pour lorsque qu'il reste moins de 3 cases vide
- 5 pour lorsque qu'il reste moins de 2 cases vide

\newpage
*** Fonction de notation 
\noindent
Nous avons une fonction de note general qui utilise une autre fonction.\\

**** Fonction de notation 
Nous avons une fonction de note générale


_Fonction =grid_note=_:
#+BEGIN_SRC c
static long int grid_note(grid g){
  long int cpt = 0;
  int cpt_case_empty = 0;
  int cpt_sign_change = 0;
  int max = 0;
  // Parcours de la grille
  for(int y = 0; y < GRID_SIDE; y++){
    for(int x = 0; x < GRID_SIDE; x++){
      cpt += get_tile(g, x, y);
      // Determination de la valeur maximum 
      if(get_tile(g, x, y) > max)
	max = get_tile(g, x, y);
      // Determination du nombre de case vide
      if(get_tile(g, x, y) == 0)
	cpt_case_empty++;
      // Monotonicite de la grille 
      cpt_sign_change += monotonicity(g, x, y);
    }
    // Bonus coin superieur gauche
    if(get_tile(g, 0, 0) == max)
      cpt += BONUS_CORNER * max;
    // Autres bonus
    cpt += BONUS_HIGH_MAXIMUM * pow(2, max);
    cpt += BONUS_SCORE * grid_score(g);
    cpt += BONUS_CASE_EMPTY * cpt_case_empty;
    // Malus si pas monotone
    cpt -= MALUS_SIGN_CHANGE * cpt_sign_change;

    return cpt;
  }
#+END_SRC

Notre fonction de notation =grid_note=, elle parcour une fois la grille et determine durant le parcours:
 - La somme des tuile de la grille
 - Récupère la valeur maximal de la grille
 - Compte le nombre de cases vides
 - Evalue la monotonicité de la grille grace a la focntion monotonicité ci-dessous



Ensuite la fonction attribue des /bonus/ et des /malus/ en fonction de la disposition de la grille.\\
_Bonus_:
 - Si le coins en haut à gauche possède la tuile maximal
 - Selon le nombre de cases vides ( Plus il y en a mieux c'est)
 - Selon le score
 - Selon la tuile maximum
_Malus_:
 - Selon sa monotonicité
\vspace{0.5cm}

_Fonction Monotonicité_:
=======
  

Nous avons besoin d'une fonction qui note la monotonicité de la grille,
c'est-à-dire que nous vérifions que les grilles sont ordonnées de manière
à avoir les meilleures tuiles en haut à gauche.
#+BEGIN_SRC c
static long int monotonicity(grid g, int x, int y){
  int cpt_sign_change = 0;
  if(x < GRID_SIDE - 1){
    if(get_tile(g, x, y) < get_tile(g, x + 1, y))
      cpt_sign_change += get_tile(g, x + 1, y) - get_tile(g, x, y);
    if(get_tile(g, y, x) < get_tile(g, y, x + 1))
      cpt_sign_change += get_tile(g, y, x + 1) - get_tile(g, y, x);
  }  
  return cpt_sign_change;
}
#+END_SRC

Nous avons besoin d'une foncion qui note la monotonicité de la grille
c'est à dire nous vérifions que les grilles sont ordonnées de manière
à ce que les meilleures soit en haut des colonnes et à gauche des lignes.
Elle compte le nombre de cases mal ordonnées.\\

\hspace{1.2cm} +\leftarrow\\
+\uparrow
\begin{tabular}{ | c | c | c | c | }


\hline
64 & 32 & 16 & 8 \\ \hline
32 & 16 & 8  & 4 \\ \hline
16 & 8  & 4  & 2 \\ \hline
8  & 4  & 2  & 0 \\ \hline
\end{tabular}


\newpage
* Architecture du Projet
#+BEGIN_EXAMPLE
  Projet-Jeu 
       |                                                                                      
       + - README.txt                                             
       + - Makefile                                           
       + - include                                      
       |    |                                      
       |    + - grid.h                                      
       |    + - strategy.h                                      
       |    + - gridSDL.h                                      
       |
       + - src
            |                                           
            + - grid                                           
            |     |                                      
            |     + - Makefile                                      
            |     + - grid.c                                      
            |
            + - test-fonction                                      
            |     |                                      
            |     + - Makefile                                      
            |     + - fonction-test.c                                      
            |     + - main-fonction-test.c                                      
            |                                          
            + - ncurses
            |     |
            |     + - Makefile                                      
            |     + - main-ncurses.c                                      
            |     + - highscore_ncurses.txt                                      
            |                                           
            + - sdl
            |     |                                      
            |     + - Makefile                                      
            |     + - gridSDL.c                                      
            |     + - main-sdl.c
            |     + - arial.ttf                                      
            |     + - leadcoat.ttf                                      
            |     + - animation_penguin                                     
            |     |     + ...                               
            |     |                                      
            |     + - menu_button                                     
            |     |     + ...                               
            |     |                                      
            |     + - tiles
            |           + ...                               
            |                                           
            + - startegy
                  |                                      
                  + - Makefile                                      
                  + - A2_emery_gouraud_kirov_pouteau_fast.c
                  + - A2_emery_gouraud_kirov_pouteau_low.c
                  + - main-graphique-fast.c
                  + - main-repetition-fast.c
                  + - main-graphique-low.c
                  + - main-repetition-low.c
                  

#+END_EXAMPLE

  On a choisit une architecture classique pour notre projet.
   - Un dossier include/ pour toutes les interfaces
   - Un dossier src/ contenant
     - Un dossier grid/ contenant les implementation du jeu général
     - Un dossier ncurses/ contenant l'implementation de l'interface du terminal
     - Un dossier sdl/ contenant l'implementation de l'interface graphique et les différentes images necessaires.
     - Un dossier strategy/ contenant nos deux strategies fast/low et differentes implementation pour observer le deroulement des intelligence artificielle.
     - Un dossier test-fonction/ contenant l'implementation des tests


* Répartition du travail

Nous avons tout les quatres travailler à implémentation de grid.c
Nous nous sommes tous entraidé à la réalisation de ce projet (comme le Rapport, correction final des fichiers ..) 
Ensuite nous nous sommes répartit le travail comme suit:

_Ysabelle Emery_:
- Réalsiation des test de départ 
- Correction des erreurs et relecture complète des fichiers
- realisation de toutes les images du projet
- Participation à la ncurses
- Correction de tous les test pour les rendre extensible avec =GRID_SIDE= 

_Jimmy Gouraud_:
- Correction orthographique du projet avec Relecture et mise des variables en anglais
- Réalisation quasiment entière de l'implementation de l'interface graphique SDL
- Intégration d'un menu et d'une animation à l'interface
- Réalisation de commentaire

_Yordan Kirov_:
- Travail sur les tests 
- Conception de différentes fonction de notation de grille pour l'intelligence artificielle
- Réalisation de commentaire
- Travail sur le \LaTeX

_Sébastien Pouteau_:
- Réalisation de l'interface ncurses et correction pour la rendre extensible ( après première evaluation)
- Réalisation de la fonction =do_move= et =can_move= factorisé
- Réalisation de tout les Makefile et arborescence du projet et creation du dépot
- Réalisation des tests de la première version 
- Realisation de l'étude de profondeur des fonctions de l'intelligence artificelle
- Normalisation des fichiers de strategie

* Problème rencontrer
Liste des problèmes rencontrés:
- Syncronisation entre l'équipe
- Utilisation des outils au début (comme svn, gdb, Makefile .. ) 
- Problème de comprehension du contrat de certaine fonction
- Génération des librairie dynamique

* Critique des outils

- GDB: Difficulté de prise en main, mais permet un débeugage efficace
- SVN: 
  - Probleme lors des commit/up sur nos machines
  - Problème de conflit entre les versions
  - Permet une bonne gestion d'un projet
  - permet d'avoir acces au ancienne version
 
- Doxygène: Normalisation de tous les contrats des fonctions assez fastidieux. Mais produit une documentation complète
- \LaTeX: 





